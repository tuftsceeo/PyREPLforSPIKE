{"ast":null,"code":"'use strict';\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];\n\nconst noop = () => {};\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\n\n\nasync function prompt() {\n  let questions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let {\n    onSubmit = noop,\n    onCancel = noop\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type, lastPrompt;\n\n  const getFormattedAnswer = async function (question, answer) {\n    let skipValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n\n    return question.format ? await question.format(answer, answers) : answer;\n  };\n\n  for (question of questions) {\n    ({\n      name,\n      type\n    } = question); // evaluate type first and skip if type is a falsy value\n\n    if (typeof type === 'function') {\n      type = await type(answer, { ...answers\n      }, question);\n      question['type'] = type;\n    }\n\n    if (!type) continue; // if property is a function, invoke it unless it's a special function\n\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, { ...answers\n      }, lastPrompt) : value;\n    }\n\n    lastPrompt = question;\n\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    } // update vars in case they changed\n\n\n    ({\n      name,\n      type\n    } = question);\n\n    if (prompts[type] === void 0) {\n      throw new Error(`prompt type (${type}) is not defined`);\n    }\n\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n\n    if (quit) return answers;\n  }\n\n  return answers;\n}\n\nfunction getInjectedAnswer(injected, deafultValue) {\n  const answer = injected.shift();\n\n  if (answer instanceof Error) {\n    throw answer;\n  }\n\n  return answer === undefined ? deafultValue : answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, {\n  prompt,\n  prompts,\n  inject,\n  override\n});","map":{"version":3,"names":["prompts","require","passOn","noop","prompt","questions","onSubmit","onCancel","answers","override","_override","concat","answer","question","quit","name","type","lastPrompt","getFormattedAnswer","skipValidation","validate","format","key","includes","value","message","Error","undefined","_injected","getInjectedAnswer","initial","err","injected","deafultValue","shift","inject","Object","assign","module","exports"],"sources":["C:/Users/gsess/node_modules/prompts/lib/index.js"],"sourcesContent":["'use strict';\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];\nconst noop = () => {};\n\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\nasync function prompt(questions=[], { onSubmit=noop, onCancel=noop }={}) {\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type, lastPrompt;\n\n  const getFormattedAnswer = async (question, answer, skipValidation = false) => {\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n    return question.format ? await question.format(answer, answers) : answer\n  };\n\n  for (question of questions) {\n    ({ name, type } = question);\n\n    // evaluate type first and skip if type is a falsy value\n    if (typeof type === 'function') {\n      type = await type(answer, { ...answers }, question)\n      question['type'] = type\n    }\n    if (!type) continue;\n\n    // if property is a function, invoke it unless it's a special function\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, { ...answers }, lastPrompt) : value;\n    }\n\n    lastPrompt = question;\n\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    }\n\n    // update vars in case they changed\n    ({ name, type } = question);\n\n    if (prompts[type] === void 0) {\n      throw new Error(`prompt type (${type}) is not defined`);\n    }\n\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n\n    if (quit) return answers;\n  }\n\n  return answers;\n}\n\nfunction getInjectedAnswer(injected, deafultValue) {\n  const answer = injected.shift();\n    if (answer instanceof Error) {\n      throw answer;\n    }\n\n    return (answer === undefined) ? deafultValue : answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, { prompt, prompts, inject, override });\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}