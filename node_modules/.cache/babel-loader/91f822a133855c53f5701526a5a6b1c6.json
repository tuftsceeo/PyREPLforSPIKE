{"ast":null,"code":"module.exports = collect;\n\nfunction collect(stream) {\n  if (stream._collected) return;\n  if (stream._paused) return stream.on('resume', collect.bind(null, stream));\n  stream._collected = true;\n  stream.pause();\n  stream.on('data', save);\n  stream.on('end', save);\n  var buf = [];\n\n  function save(b) {\n    if (typeof b === 'string') b = new Buffer(b);\n    if (Buffer.isBuffer(b) && !b.length) return;\n    buf.push(b);\n  }\n\n  stream.on('entry', saveEntry);\n  var entryBuffer = [];\n\n  function saveEntry(e) {\n    collect(e);\n    entryBuffer.push(e);\n  }\n\n  stream.on('proxy', proxyPause);\n\n  function proxyPause(p) {\n    p.pause();\n  } // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n\n\n  stream.pipe = function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0;\n\n      (function unblockEntry() {\n        var entry = entryBuffer[e++]; // console.error(\" ==== unblock entry\", entry && entry.path)\n\n        if (!entry) return resume();\n        entry.on('end', unblockEntry);\n        if (dest) dest.add(entry);else stream.emit('entry', entry);\n      })();\n\n      function resume() {\n        stream.removeListener('entry', saveEntry);\n        stream.removeListener('data', save);\n        stream.removeListener('end', save);\n        stream.pipe = orig;\n        if (dest) stream.pipe(dest);\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b);else stream.emit('end');\n        });\n        stream.resume();\n      }\n\n      return dest;\n    };\n  }(stream.pipe);\n}","map":{"version":3,"names":["module","exports","collect","stream","_collected","_paused","on","bind","pause","save","buf","b","Buffer","isBuffer","length","push","saveEntry","entryBuffer","e","proxyPause","p","pipe","orig","dest","unblockEntry","entry","resume","add","emit","removeListener","forEach"],"sources":["C:/Users/gsess/node_modules/fstream/lib/collect.js"],"sourcesContent":["module.exports = collect\n\nfunction collect (stream) {\n  if (stream._collected) return\n\n  if (stream._paused) return stream.on('resume', collect.bind(null, stream))\n\n  stream._collected = true\n  stream.pause()\n\n  stream.on('data', save)\n  stream.on('end', save)\n  var buf = []\n  function save (b) {\n    if (typeof b === 'string') b = new Buffer(b)\n    if (Buffer.isBuffer(b) && !b.length) return\n    buf.push(b)\n  }\n\n  stream.on('entry', saveEntry)\n  var entryBuffer = []\n  function saveEntry (e) {\n    collect(e)\n    entryBuffer.push(e)\n  }\n\n  stream.on('proxy', proxyPause)\n  function proxyPause (p) {\n    p.pause()\n  }\n\n  // replace the pipe method with a new version that will\n  // unlock the buffered stuff.  if you just call .pipe()\n  // without a destination, then it'll re-play the events.\n  stream.pipe = (function (orig) {\n    return function (dest) {\n      // console.error(' === open the pipes', dest && dest.path)\n\n      // let the entries flow through one at a time.\n      // Once they're all done, then we can resume completely.\n      var e = 0\n      ;(function unblockEntry () {\n        var entry = entryBuffer[e++]\n        // console.error(\" ==== unblock entry\", entry && entry.path)\n        if (!entry) return resume()\n        entry.on('end', unblockEntry)\n        if (dest) dest.add(entry)\n        else stream.emit('entry', entry)\n      })()\n\n      function resume () {\n        stream.removeListener('entry', saveEntry)\n        stream.removeListener('data', save)\n        stream.removeListener('end', save)\n\n        stream.pipe = orig\n        if (dest) stream.pipe(dest)\n\n        buf.forEach(function (b) {\n          if (b) stream.emit('data', b)\n          else stream.emit('end')\n        })\n\n        stream.resume()\n      }\n\n      return dest\n    }\n  })(stream.pipe)\n}\n"],"mappings":"AAAAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,SAASA,OAAT,CAAkBC,MAAlB,EAA0B;EACxB,IAAIA,MAAM,CAACC,UAAX,EAAuB;EAEvB,IAAID,MAAM,CAACE,OAAX,EAAoB,OAAOF,MAAM,CAACG,EAAP,CAAU,QAAV,EAAoBJ,OAAO,CAACK,IAAR,CAAa,IAAb,EAAmBJ,MAAnB,CAApB,CAAP;EAEpBA,MAAM,CAACC,UAAP,GAAoB,IAApB;EACAD,MAAM,CAACK,KAAP;EAEAL,MAAM,CAACG,EAAP,CAAU,MAAV,EAAkBG,IAAlB;EACAN,MAAM,CAACG,EAAP,CAAU,KAAV,EAAiBG,IAAjB;EACA,IAAIC,GAAG,GAAG,EAAV;;EACA,SAASD,IAAT,CAAeE,CAAf,EAAkB;IAChB,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2BA,CAAC,GAAG,IAAIC,MAAJ,CAAWD,CAAX,CAAJ;IAC3B,IAAIC,MAAM,CAACC,QAAP,CAAgBF,CAAhB,KAAsB,CAACA,CAAC,CAACG,MAA7B,EAAqC;IACrCJ,GAAG,CAACK,IAAJ,CAASJ,CAAT;EACD;;EAEDR,MAAM,CAACG,EAAP,CAAU,OAAV,EAAmBU,SAAnB;EACA,IAAIC,WAAW,GAAG,EAAlB;;EACA,SAASD,SAAT,CAAoBE,CAApB,EAAuB;IACrBhB,OAAO,CAACgB,CAAD,CAAP;IACAD,WAAW,CAACF,IAAZ,CAAiBG,CAAjB;EACD;;EAEDf,MAAM,CAACG,EAAP,CAAU,OAAV,EAAmBa,UAAnB;;EACA,SAASA,UAAT,CAAqBC,CAArB,EAAwB;IACtBA,CAAC,CAACZ,KAAF;EACD,CA3BuB,CA6BxB;EACA;EACA;;;EACAL,MAAM,CAACkB,IAAP,GAAe,UAAUC,IAAV,EAAgB;IAC7B,OAAO,UAAUC,IAAV,EAAgB;MACrB;MAEA;MACA;MACA,IAAIL,CAAC,GAAG,CAAR;;MACC,CAAC,SAASM,YAAT,GAAyB;QACzB,IAAIC,KAAK,GAAGR,WAAW,CAACC,CAAC,EAAF,CAAvB,CADyB,CAEzB;;QACA,IAAI,CAACO,KAAL,EAAY,OAAOC,MAAM,EAAb;QACZD,KAAK,CAACnB,EAAN,CAAS,KAAT,EAAgBkB,YAAhB;QACA,IAAID,IAAJ,EAAUA,IAAI,CAACI,GAAL,CAASF,KAAT,EAAV,KACKtB,MAAM,CAACyB,IAAP,CAAY,OAAZ,EAAqBH,KAArB;MACN,CAPA;;MASD,SAASC,MAAT,GAAmB;QACjBvB,MAAM,CAAC0B,cAAP,CAAsB,OAAtB,EAA+Bb,SAA/B;QACAb,MAAM,CAAC0B,cAAP,CAAsB,MAAtB,EAA8BpB,IAA9B;QACAN,MAAM,CAAC0B,cAAP,CAAsB,KAAtB,EAA6BpB,IAA7B;QAEAN,MAAM,CAACkB,IAAP,GAAcC,IAAd;QACA,IAAIC,IAAJ,EAAUpB,MAAM,CAACkB,IAAP,CAAYE,IAAZ;QAEVb,GAAG,CAACoB,OAAJ,CAAY,UAAUnB,CAAV,EAAa;UACvB,IAAIA,CAAJ,EAAOR,MAAM,CAACyB,IAAP,CAAY,MAAZ,EAAoBjB,CAApB,EAAP,KACKR,MAAM,CAACyB,IAAP,CAAY,KAAZ;QACN,CAHD;QAKAzB,MAAM,CAACuB,MAAP;MACD;;MAED,OAAOH,IAAP;IACD,CAhCD;EAiCD,CAlCa,CAkCXpB,MAAM,CAACkB,IAlCI,CAAd;AAmCD"},"metadata":{},"sourceType":"script"}