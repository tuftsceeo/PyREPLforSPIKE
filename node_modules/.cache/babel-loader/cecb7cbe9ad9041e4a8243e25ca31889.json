{"ast":null,"code":"module.exports = LinkWriter;\n\nvar fs = require('graceful-fs');\n\nvar Writer = require('./writer.js');\n\nvar inherits = require('inherits');\n\nvar path = require('path');\n\nvar rimraf = require('rimraf');\n\ninherits(LinkWriter, Writer);\n\nfunction LinkWriter(props) {\n  var self = this;\n\n  if (!(self instanceof LinkWriter)) {\n    throw new Error('LinkWriter must be called as constructor.');\n  } // should already be established as a Link type\n\n\n  if (!(props.type === 'Link' && props.Link || props.type === 'SymbolicLink' && props.SymbolicLink)) {\n    throw new Error('Non-link type ' + props.type);\n  }\n\n  if (props.linkpath === '') props.linkpath = '.';\n\n  if (!props.linkpath) {\n    self.error('Need linkpath property to create ' + props.type);\n  }\n\n  Writer.call(this, props);\n}\n\nLinkWriter.prototype._create = function () {\n  // console.error(\" LW _create\")\n  var self = this;\n  var hard = self.type === 'Link' || process.platform === 'win32';\n  var link = hard ? 'link' : 'symlink';\n  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath; // can only change the link path by clobbering\n  // For hard links, let's just assume that's always the case, since\n  // there's no good way to read them if we don't already know.\n\n  if (hard) return clobber(self, lp, link);\n  fs.readlink(self._path, function (er, p) {\n    // only skip creation if it's exactly the same link\n    if (p && p === lp) return finish(self);\n    clobber(self, lp, link);\n  });\n};\n\nfunction clobber(self, lp, link) {\n  rimraf(self._path, function (er) {\n    if (er) return self.error(er);\n    create(self, lp, link);\n  });\n}\n\nfunction create(self, lp, link) {\n  fs[link](lp, self._path, function (er) {\n    // if this is a hard link, and we're in the process of writing out a\n    // directory, it's very possible that the thing we're linking to\n    // doesn't exist yet (especially if it was intended as a symlink),\n    // so swallow ENOENT errors here and just soldier in.\n    // Additionally, an EPERM or EACCES can happen on win32 if it's trying\n    // to make a link to a directory.  Again, just skip it.\n    // A better solution would be to have fs.symlink be supported on\n    // windows in some nice fashion.\n    if (er) {\n      if ((er.code === 'ENOENT' || er.code === 'EACCES' || er.code === 'EPERM') && process.platform === 'win32') {\n        self.ready = true;\n        self.emit('ready');\n        self.emit('end');\n        self.emit('close');\n\n        self.end = self._finish = function () {};\n      } else return self.error(er);\n    }\n\n    finish(self);\n  });\n}\n\nfunction finish(self) {\n  self.ready = true;\n  self.emit('ready');\n  if (self._ended && !self._finished) self._finish();\n}\n\nLinkWriter.prototype.end = function () {\n  // console.error(\"LW finish in end\")\n  this._ended = true;\n\n  if (this.ready) {\n    this._finished = true;\n\n    this._finish();\n  }\n};","map":{"version":3,"names":["module","exports","LinkWriter","fs","require","Writer","inherits","path","rimraf","props","self","Error","type","Link","SymbolicLink","linkpath","error","call","prototype","_create","hard","process","platform","link","lp","resolve","dirname","clobber","readlink","_path","er","p","finish","create","code","ready","emit","end","_finish","_ended","_finished"],"sources":["C:/Users/gsess/node_modules/fstream/lib/link-writer.js"],"sourcesContent":["module.exports = LinkWriter\n\nvar fs = require('graceful-fs')\nvar Writer = require('./writer.js')\nvar inherits = require('inherits')\nvar path = require('path')\nvar rimraf = require('rimraf')\n\ninherits(LinkWriter, Writer)\n\nfunction LinkWriter (props) {\n  var self = this\n  if (!(self instanceof LinkWriter)) {\n    throw new Error('LinkWriter must be called as constructor.')\n  }\n\n  // should already be established as a Link type\n  if (!((props.type === 'Link' && props.Link) ||\n    (props.type === 'SymbolicLink' && props.SymbolicLink))) {\n    throw new Error('Non-link type ' + props.type)\n  }\n\n  if (props.linkpath === '') props.linkpath = '.'\n  if (!props.linkpath) {\n    self.error('Need linkpath property to create ' + props.type)\n  }\n\n  Writer.call(this, props)\n}\n\nLinkWriter.prototype._create = function () {\n  // console.error(\" LW _create\")\n  var self = this\n  var hard = self.type === 'Link' || process.platform === 'win32'\n  var link = hard ? 'link' : 'symlink'\n  var lp = hard ? path.resolve(self.dirname, self.linkpath) : self.linkpath\n\n  // can only change the link path by clobbering\n  // For hard links, let's just assume that's always the case, since\n  // there's no good way to read them if we don't already know.\n  if (hard) return clobber(self, lp, link)\n\n  fs.readlink(self._path, function (er, p) {\n    // only skip creation if it's exactly the same link\n    if (p && p === lp) return finish(self)\n    clobber(self, lp, link)\n  })\n}\n\nfunction clobber (self, lp, link) {\n  rimraf(self._path, function (er) {\n    if (er) return self.error(er)\n    create(self, lp, link)\n  })\n}\n\nfunction create (self, lp, link) {\n  fs[link](lp, self._path, function (er) {\n    // if this is a hard link, and we're in the process of writing out a\n    // directory, it's very possible that the thing we're linking to\n    // doesn't exist yet (especially if it was intended as a symlink),\n    // so swallow ENOENT errors here and just soldier in.\n    // Additionally, an EPERM or EACCES can happen on win32 if it's trying\n    // to make a link to a directory.  Again, just skip it.\n    // A better solution would be to have fs.symlink be supported on\n    // windows in some nice fashion.\n    if (er) {\n      if ((er.code === 'ENOENT' ||\n        er.code === 'EACCES' ||\n        er.code === 'EPERM') && process.platform === 'win32') {\n        self.ready = true\n        self.emit('ready')\n        self.emit('end')\n        self.emit('close')\n        self.end = self._finish = function () {}\n      } else return self.error(er)\n    }\n    finish(self)\n  })\n}\n\nfunction finish (self) {\n  self.ready = true\n  self.emit('ready')\n  if (self._ended && !self._finished) self._finish()\n}\n\nLinkWriter.prototype.end = function () {\n  // console.error(\"LW finish in end\")\n  this._ended = true\n  if (this.ready) {\n    this._finished = true\n    this._finish()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}