{"ast":null,"code":"// parse a 512-byte header block to a data object, or vice-versa\n// If the data won't fit nicely in a simple header, then generate\n// the appropriate extended header file, and return that.\nmodule.exports = TarHeader;\n\nvar tar = require(\"../tar.js\"),\n    fields = tar.fields,\n    fieldOffs = tar.fieldOffs,\n    fieldEnds = tar.fieldEnds,\n    fieldSize = tar.fieldSize,\n    numeric = tar.numeric,\n    assert = require(\"assert\").ok,\n    space = \" \".charCodeAt(0),\n    slash = \"/\".charCodeAt(0),\n    bslash = process.platform === \"win32\" ? \"\\\\\".charCodeAt(0) : null;\n\nfunction TarHeader(block) {\n  if (!(this instanceof TarHeader)) return new TarHeader(block);\n  if (block) this.decode(block);\n}\n\nTarHeader.prototype = {\n  decode: decode,\n  encode: encode,\n  calcSum: calcSum,\n  checkSum: checkSum\n};\nTarHeader.parseNumeric = parseNumeric;\nTarHeader.encode = encode;\nTarHeader.decode = decode; // note that this will only do the normal ustar header, not any kind\n// of extended posix header file.  If something doesn't fit comfortably,\n// then it will set obj.needExtended = true, and set the block to\n// the closest approximation.\n\nfunction encode(obj) {\n  if (!obj && !(this instanceof TarHeader)) throw new Error(\"encode must be called on a TarHeader, or supplied an object\");\n  obj = obj || this;\n  var block = obj.block = new Buffer(512); // if the object has a \"prefix\", then that's actually an extension of\n  // the path field.\n\n  if (obj.prefix) {\n    // console.error(\"%% header encoding, got a prefix\", obj.prefix)\n    obj.path = obj.prefix + \"/\" + obj.path; // console.error(\"%% header encoding, prefixed path\", obj.path)\n\n    obj.prefix = \"\";\n  }\n\n  obj.needExtended = false;\n\n  if (obj.mode) {\n    if (typeof obj.mode === \"string\") obj.mode = parseInt(obj.mode, 8);\n    obj.mode = obj.mode & 0777;\n  }\n\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n        off = fieldOffs[f],\n        end = fieldEnds[f],\n        ret;\n\n    switch (field) {\n      case \"cksum\":\n        // special, done below, after all the others\n        break;\n\n      case \"prefix\":\n        // special, this is an extension of the \"path\" field.\n        // console.error(\"%% header encoding, skip prefix later\")\n        break;\n\n      case \"type\":\n        // convert from long name to a single char.\n        var type = obj.type || \"0\";\n\n        if (type.length > 1) {\n          type = tar.types[obj.type];\n          if (!type) type = \"0\";\n        }\n\n        writeText(block, off, end, type);\n        break;\n\n      case \"path\":\n        // uses the \"prefix\" field if > 100 bytes, but <= 255\n        var pathLen = Buffer.byteLength(obj.path),\n            pathFSize = fieldSize[fields.path],\n            prefFSize = fieldSize[fields.prefix]; // paths between 100 and 255 should use the prefix field.\n        // longer than 255\n\n        if (pathLen > pathFSize && pathLen <= pathFSize + prefFSize) {\n          // need to find a slash somewhere in the middle so that\n          // path and prefix both fit in their respective fields\n          var searchStart = pathLen - 1 - pathFSize,\n              searchEnd = prefFSize,\n              found = false,\n              pathBuf = new Buffer(obj.path);\n\n          for (var s = searchStart; s <= searchEnd; s++) {\n            if (pathBuf[s] === slash || pathBuf[s] === bslash) {\n              found = s;\n              break;\n            }\n          }\n\n          if (found !== false) {\n            prefix = pathBuf.slice(0, found).toString(\"utf8\");\n            path = pathBuf.slice(found + 1).toString(\"utf8\");\n            ret = writeText(block, off, end, path);\n            off = fieldOffs[fields.prefix];\n            end = fieldEnds[fields.prefix]; // console.error(\"%% header writing prefix\", off, end, prefix)\n\n            ret = writeText(block, off, end, prefix) || ret;\n            break;\n          }\n        } // paths less than 100 chars don't need a prefix\n        // and paths longer than 255 need an extended header and will fail\n        // on old implementations no matter what we do here.\n        // Null out the prefix, and fallthrough to default.\n        // console.error(\"%% header writing no prefix\")\n\n\n        var poff = fieldOffs[fields.prefix],\n            pend = fieldEnds[fields.prefix];\n        writeText(block, poff, pend, \"\");\n      // fallthrough\n      // all other fields are numeric or text\n\n      default:\n        ret = numeric[field] ? writeNumeric(block, off, end, obj[field]) : writeText(block, off, end, obj[field] || \"\");\n        break;\n    }\n\n    obj.needExtended = obj.needExtended || ret;\n  }\n\n  var off = fieldOffs[fields.cksum],\n      end = fieldEnds[fields.cksum];\n  writeNumeric(block, off, end, calcSum.call(this, block));\n  return block;\n} // if it's a negative number, or greater than will fit,\n// then use write256.\n\n\nvar MAXNUM = {\n  12: 077777777777,\n  11: 07777777777,\n  8: 07777777,\n  7: 0777777\n};\n\nfunction writeNumeric(block, off, end, num) {\n  var writeLen = end - off,\n      maxNum = MAXNUM[writeLen] || 0;\n  num = num || 0; // console.error(\"  numeric\", num)\n\n  if (num instanceof Date || Object.prototype.toString.call(num) === \"[object Date]\") {\n    num = num.getTime() / 1000;\n  }\n\n  if (num > maxNum || num < 0) {\n    write256(block, off, end, num); // need an extended header if negative or too big.\n\n    return true;\n  } // god, tar is so annoying\n  // if the string is small enough, you should put a space\n  // between the octal string and the \\0, but if it doesn't\n  // fit, then don't.\n\n\n  var numStr = Math.floor(num).toString(8);\n  if (num < MAXNUM[writeLen - 1]) numStr += \" \"; // pad with \"0\" chars\n\n  if (numStr.length < writeLen) {\n    numStr = new Array(writeLen - numStr.length).join(\"0\") + numStr;\n  }\n\n  if (numStr.length !== writeLen - 1) {\n    throw new Error(\"invalid length: \" + JSON.stringify(numStr) + \"\\n\" + \"expected: \" + writeLen);\n  }\n\n  block.write(numStr, off, writeLen, \"utf8\");\n  block[end - 1] = 0;\n}\n\nfunction write256(block, off, end, num) {\n  var buf = block.slice(off, end);\n  var positive = num >= 0;\n  buf[0] = positive ? 0x80 : 0xFF; // get the number as a base-256 tuple\n\n  if (!positive) num *= -1;\n  var tuple = [];\n\n  do {\n    var n = num % 256;\n    tuple.push(n);\n    num = (num - n) / 256;\n  } while (num);\n\n  var bytes = tuple.length;\n  var fill = buf.length - bytes;\n\n  for (var i = 1; i < fill; i++) {\n    buf[i] = positive ? 0 : 0xFF;\n  } // tuple is a base256 number, with [0] as the *least* significant byte\n  // if it's negative, then we need to flip all the bits once we hit the\n  // first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-\n  // complement is (0xFF - n).\n\n\n  var zero = true;\n\n  for (i = bytes; i > 0; i--) {\n    var byte = tuple[bytes - i];\n    if (positive) buf[fill + i] = byte;else if (zero && byte === 0) buf[fill + i] = 0;else if (zero) {\n      zero = false;\n      buf[fill + i] = 0x100 - byte;\n    } else buf[fill + i] = 0xFF - byte;\n  }\n}\n\nfunction writeText(block, off, end, str) {\n  // strings are written as utf8, then padded with \\0\n  var strLen = Buffer.byteLength(str),\n      writeLen = Math.min(strLen, end - off) // non-ascii fields need extended headers\n  // long fields get truncated\n  ,\n      needExtended = strLen !== str.length || strLen > writeLen; // write the string, and null-pad\n\n  if (writeLen > 0) block.write(str, off, writeLen, \"utf8\");\n\n  for (var i = off + writeLen; i < end; i++) block[i] = 0;\n\n  return needExtended;\n}\n\nfunction calcSum(block) {\n  block = block || this.block;\n  assert(Buffer.isBuffer(block) && block.length === 512);\n  if (!block) throw new Error(\"Need block to checksum\"); // now figure out what it would be if the cksum was \"        \"\n\n  var sum = 0,\n      start = fieldOffs[fields.cksum],\n      end = fieldEnds[fields.cksum];\n\n  for (var i = 0; i < fieldOffs[fields.cksum]; i++) {\n    sum += block[i];\n  }\n\n  for (var i = start; i < end; i++) {\n    sum += space;\n  }\n\n  for (var i = end; i < 512; i++) {\n    sum += block[i];\n  }\n\n  return sum;\n}\n\nfunction checkSum(block) {\n  var sum = calcSum.call(this, block);\n  block = block || this.block;\n  var cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum]);\n  cksum = parseNumeric(cksum);\n  return cksum === sum;\n}\n\nfunction decode(block) {\n  block = block || this.block;\n  assert(Buffer.isBuffer(block) && block.length === 512);\n  this.block = block;\n  this.cksumValid = this.checkSum();\n  var prefix = null; // slice off each field.\n\n  for (var f = 0; fields[f] !== null; f++) {\n    var field = fields[f],\n        val = block.slice(fieldOffs[f], fieldEnds[f]);\n\n    switch (field) {\n      case \"ustar\":\n        // if not ustar, then everything after that is just padding.\n        if (val.toString() !== \"ustar\\0\") {\n          this.ustar = false;\n          return;\n        } else {\n          // console.error(\"ustar:\", val, val.toString())\n          this.ustar = val.toString();\n        }\n\n        break;\n      // prefix is special, since it might signal the xstar header\n\n      case \"prefix\":\n        var atime = parseNumeric(val.slice(131, 131 + 12)),\n            ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12));\n\n        if ((val[130] === 0 || val[130] === space) && typeof atime === \"number\" && typeof ctime === \"number\" && val[131 + 12] === space && val[131 + 12 + 12] === space) {\n          this.atime = atime;\n          this.ctime = ctime;\n          val = val.slice(0, 130);\n        }\n\n        prefix = val.toString(\"utf8\").replace(/\\0+$/, \"\"); // console.error(\"%% header reading prefix\", prefix)\n\n        break;\n      // all other fields are null-padding text\n      // or a number.\n\n      default:\n        if (numeric[field]) {\n          this[field] = parseNumeric(val);\n        } else {\n          this[field] = val.toString(\"utf8\").replace(/\\0+$/, \"\");\n        }\n\n        break;\n    }\n  } // if we got a prefix, then prepend it to the path.\n\n\n  if (prefix) {\n    this.path = prefix + \"/\" + this.path; // console.error(\"%% header got a prefix\", this.path)\n  }\n}\n\nfunction parse256(buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive;\n  if (buf[0] === 0x80) positive = true;else if (buf[0] === 0xFF) positive = false;else return null; // build up a base-256 tuple from the least sig to the highest\n\n  var zero = false,\n      tuple = [];\n\n  for (var i = buf.length - 1; i > 0; i--) {\n    var byte = buf[i];\n    if (positive) tuple.push(byte);else if (zero && byte === 0) tuple.push(0);else if (zero) {\n      zero = false;\n      tuple.push(0x100 - byte);\n    } else tuple.push(0xFF - byte);\n  }\n\n  for (var sum = 0, i = 0, l = tuple.length; i < l; i++) {\n    sum += tuple[i] * Math.pow(256, i);\n  }\n\n  return positive ? sum : -1 * sum;\n}\n\nfunction parseNumeric(f) {\n  if (f[0] & 0x80) return parse256(f);\n  var str = f.toString(\"utf8\").split(\"\\0\")[0].trim(),\n      res = parseInt(str, 8);\n  return isNaN(res) ? null : res;\n}","map":{"version":3,"names":["module","exports","TarHeader","tar","require","fields","fieldOffs","fieldEnds","fieldSize","numeric","assert","ok","space","charCodeAt","slash","bslash","process","platform","block","decode","prototype","encode","calcSum","checkSum","parseNumeric","obj","Error","Buffer","prefix","path","needExtended","mode","parseInt","f","field","off","end","ret","type","length","types","writeText","pathLen","byteLength","pathFSize","prefFSize","searchStart","searchEnd","found","pathBuf","s","slice","toString","poff","pend","writeNumeric","cksum","call","MAXNUM","num","writeLen","maxNum","Date","Object","getTime","write256","numStr","Math","floor","Array","join","JSON","stringify","write","buf","positive","tuple","n","push","bytes","fill","i","zero","byte","str","strLen","min","isBuffer","sum","start","cksumValid","val","ustar","atime","ctime","replace","parse256","l","pow","split","trim","res","isNaN"],"sources":["C:/Users/gsess/node_modules/tar/lib/header.js"],"sourcesContent":["// parse a 512-byte header block to a data object, or vice-versa\n// If the data won't fit nicely in a simple header, then generate\n// the appropriate extended header file, and return that.\n\nmodule.exports = TarHeader\n\nvar tar = require(\"../tar.js\")\n  , fields = tar.fields\n  , fieldOffs = tar.fieldOffs\n  , fieldEnds = tar.fieldEnds\n  , fieldSize = tar.fieldSize\n  , numeric = tar.numeric\n  , assert = require(\"assert\").ok\n  , space = \" \".charCodeAt(0)\n  , slash = \"/\".charCodeAt(0)\n  , bslash = process.platform === \"win32\" ? \"\\\\\".charCodeAt(0) : null\n\nfunction TarHeader (block) {\n  if (!(this instanceof TarHeader)) return new TarHeader(block)\n  if (block) this.decode(block)\n}\n\nTarHeader.prototype =\n  { decode : decode\n  , encode: encode\n  , calcSum: calcSum\n  , checkSum: checkSum\n  }\n\nTarHeader.parseNumeric = parseNumeric\nTarHeader.encode = encode\nTarHeader.decode = decode\n\n// note that this will only do the normal ustar header, not any kind\n// of extended posix header file.  If something doesn't fit comfortably,\n// then it will set obj.needExtended = true, and set the block to\n// the closest approximation.\nfunction encode (obj) {\n  if (!obj && !(this instanceof TarHeader)) throw new Error(\n    \"encode must be called on a TarHeader, or supplied an object\")\n\n  obj = obj || this\n  var block = obj.block = new Buffer(512)\n\n  // if the object has a \"prefix\", then that's actually an extension of\n  // the path field.\n  if (obj.prefix) {\n    // console.error(\"%% header encoding, got a prefix\", obj.prefix)\n    obj.path = obj.prefix + \"/\" + obj.path\n    // console.error(\"%% header encoding, prefixed path\", obj.path)\n    obj.prefix = \"\"\n  }\n\n  obj.needExtended = false\n\n  if (obj.mode) {\n    if (typeof obj.mode === \"string\") obj.mode = parseInt(obj.mode, 8)\n    obj.mode = obj.mode & 0777\n  }\n\n  for (var f = 0; fields[f] !== null; f ++) {\n    var field = fields[f]\n      , off = fieldOffs[f]\n      , end = fieldEnds[f]\n      , ret\n\n    switch (field) {\n      case \"cksum\":\n        // special, done below, after all the others\n        break\n\n      case \"prefix\":\n        // special, this is an extension of the \"path\" field.\n        // console.error(\"%% header encoding, skip prefix later\")\n        break\n\n      case \"type\":\n        // convert from long name to a single char.\n        var type = obj.type || \"0\"\n        if (type.length > 1) {\n          type = tar.types[obj.type]\n          if (!type) type = \"0\"\n        }\n        writeText(block, off, end, type)\n        break\n\n      case \"path\":\n        // uses the \"prefix\" field if > 100 bytes, but <= 255\n        var pathLen = Buffer.byteLength(obj.path)\n          , pathFSize = fieldSize[fields.path]\n          , prefFSize = fieldSize[fields.prefix]\n\n        // paths between 100 and 255 should use the prefix field.\n        // longer than 255\n        if (pathLen > pathFSize &&\n            pathLen <= pathFSize + prefFSize) {\n          // need to find a slash somewhere in the middle so that\n          // path and prefix both fit in their respective fields\n          var searchStart = pathLen - 1 - pathFSize\n            , searchEnd = prefFSize\n            , found = false\n            , pathBuf = new Buffer(obj.path)\n\n          for ( var s = searchStart\n              ; (s <= searchEnd)\n              ; s ++ ) {\n            if (pathBuf[s] === slash || pathBuf[s] === bslash) {\n              found = s\n              break\n            }\n          }\n\n          if (found !== false) {\n            prefix = pathBuf.slice(0, found).toString(\"utf8\")\n            path = pathBuf.slice(found + 1).toString(\"utf8\")\n\n            ret = writeText(block, off, end, path)\n            off = fieldOffs[fields.prefix]\n            end = fieldEnds[fields.prefix]\n            // console.error(\"%% header writing prefix\", off, end, prefix)\n            ret = writeText(block, off, end, prefix) || ret\n            break\n          }\n        }\n\n        // paths less than 100 chars don't need a prefix\n        // and paths longer than 255 need an extended header and will fail\n        // on old implementations no matter what we do here.\n        // Null out the prefix, and fallthrough to default.\n        // console.error(\"%% header writing no prefix\")\n        var poff = fieldOffs[fields.prefix]\n          , pend = fieldEnds[fields.prefix]\n        writeText(block, poff, pend, \"\")\n        // fallthrough\n\n      // all other fields are numeric or text\n      default:\n        ret = numeric[field]\n            ? writeNumeric(block, off, end, obj[field])\n            : writeText(block, off, end, obj[field] || \"\")\n        break\n    }\n    obj.needExtended = obj.needExtended || ret\n  }\n\n  var off = fieldOffs[fields.cksum]\n    , end = fieldEnds[fields.cksum]\n\n  writeNumeric(block, off, end, calcSum.call(this, block))\n\n  return block\n}\n\n// if it's a negative number, or greater than will fit,\n// then use write256.\nvar MAXNUM = { 12: 077777777777\n             , 11: 07777777777\n             , 8 : 07777777\n             , 7 : 0777777 }\nfunction writeNumeric (block, off, end, num) {\n  var writeLen = end - off\n    , maxNum = MAXNUM[writeLen] || 0\n\n  num = num || 0\n  // console.error(\"  numeric\", num)\n\n  if (num instanceof Date ||\n      Object.prototype.toString.call(num) === \"[object Date]\") {\n    num = num.getTime() / 1000\n  }\n\n  if (num > maxNum || num < 0) {\n    write256(block, off, end, num)\n    // need an extended header if negative or too big.\n    return true\n  }\n\n  // god, tar is so annoying\n  // if the string is small enough, you should put a space\n  // between the octal string and the \\0, but if it doesn't\n  // fit, then don't.\n  var numStr = Math.floor(num).toString(8)\n  if (num < MAXNUM[writeLen - 1]) numStr += \" \"\n\n  // pad with \"0\" chars\n  if (numStr.length < writeLen) {\n    numStr = (new Array(writeLen - numStr.length).join(\"0\")) + numStr\n  }\n\n  if (numStr.length !== writeLen - 1) {\n    throw new Error(\"invalid length: \" + JSON.stringify(numStr) + \"\\n\" +\n                    \"expected: \"+writeLen)\n  }\n  block.write(numStr, off, writeLen, \"utf8\")\n  block[end - 1] = 0\n}\n\nfunction write256 (block, off, end, num) {\n  var buf = block.slice(off, end)\n  var positive = num >= 0\n  buf[0] = positive ? 0x80 : 0xFF\n\n  // get the number as a base-256 tuple\n  if (!positive) num *= -1\n  var tuple = []\n  do {\n    var n = num % 256\n    tuple.push(n)\n    num = (num - n) / 256\n  } while (num)\n\n  var bytes = tuple.length\n\n  var fill = buf.length - bytes\n  for (var i = 1; i < fill; i ++) {\n    buf[i] = positive ? 0 : 0xFF\n  }\n\n  // tuple is a base256 number, with [0] as the *least* significant byte\n  // if it's negative, then we need to flip all the bits once we hit the\n  // first non-zero bit.  The 2's-complement is (0x100 - n), and the 1's-\n  // complement is (0xFF - n).\n  var zero = true\n  for (i = bytes; i > 0; i --) {\n    var byte = tuple[bytes - i]\n    if (positive) buf[fill + i] = byte\n    else if (zero && byte === 0) buf[fill + i] = 0\n    else if (zero) {\n      zero = false\n      buf[fill + i] = 0x100 - byte\n    } else buf[fill + i] = 0xFF - byte\n  }\n}\n\nfunction writeText (block, off, end, str) {\n  // strings are written as utf8, then padded with \\0\n  var strLen = Buffer.byteLength(str)\n    , writeLen = Math.min(strLen, end - off)\n    // non-ascii fields need extended headers\n    // long fields get truncated\n    , needExtended = strLen !== str.length || strLen > writeLen\n\n  // write the string, and null-pad\n  if (writeLen > 0) block.write(str, off, writeLen, \"utf8\")\n  for (var i = off + writeLen; i < end; i ++) block[i] = 0\n\n  return needExtended\n}\n\nfunction calcSum (block) {\n  block = block || this.block\n  assert(Buffer.isBuffer(block) && block.length === 512)\n\n  if (!block) throw new Error(\"Need block to checksum\")\n\n  // now figure out what it would be if the cksum was \"        \"\n  var sum = 0\n    , start = fieldOffs[fields.cksum]\n    , end = fieldEnds[fields.cksum]\n\n  for (var i = 0; i < fieldOffs[fields.cksum]; i ++) {\n    sum += block[i]\n  }\n\n  for (var i = start; i < end; i ++) {\n    sum += space\n  }\n\n  for (var i = end; i < 512; i ++) {\n    sum += block[i]\n  }\n\n  return sum\n}\n\n\nfunction checkSum (block) {\n  var sum = calcSum.call(this, block)\n  block = block || this.block\n\n  var cksum = block.slice(fieldOffs[fields.cksum], fieldEnds[fields.cksum])\n  cksum = parseNumeric(cksum)\n\n  return cksum === sum\n}\n\nfunction decode (block) {\n  block = block || this.block\n  assert(Buffer.isBuffer(block) && block.length === 512)\n\n  this.block = block\n  this.cksumValid = this.checkSum()\n\n  var prefix = null\n\n  // slice off each field.\n  for (var f = 0; fields[f] !== null; f ++) {\n    var field = fields[f]\n      , val = block.slice(fieldOffs[f], fieldEnds[f])\n\n    switch (field) {\n      case \"ustar\":\n        // if not ustar, then everything after that is just padding.\n        if (val.toString() !== \"ustar\\0\") {\n          this.ustar = false\n          return\n        } else {\n          // console.error(\"ustar:\", val, val.toString())\n          this.ustar = val.toString()\n        }\n        break\n\n      // prefix is special, since it might signal the xstar header\n      case \"prefix\":\n        var atime = parseNumeric(val.slice(131, 131 + 12))\n          , ctime = parseNumeric(val.slice(131 + 12, 131 + 12 + 12))\n        if ((val[130] === 0 || val[130] === space) &&\n            typeof atime === \"number\" &&\n            typeof ctime === \"number\" &&\n            val[131 + 12] === space &&\n            val[131 + 12 + 12] === space) {\n          this.atime = atime\n          this.ctime = ctime\n          val = val.slice(0, 130)\n        }\n        prefix = val.toString(\"utf8\").replace(/\\0+$/, \"\")\n        // console.error(\"%% header reading prefix\", prefix)\n        break\n\n      // all other fields are null-padding text\n      // or a number.\n      default:\n        if (numeric[field]) {\n          this[field] = parseNumeric(val)\n        } else {\n          this[field] = val.toString(\"utf8\").replace(/\\0+$/, \"\")\n        }\n        break\n    }\n  }\n\n  // if we got a prefix, then prepend it to the path.\n  if (prefix) {\n    this.path = prefix + \"/\" + this.path\n    // console.error(\"%% header got a prefix\", this.path)\n  }\n}\n\nfunction parse256 (buf) {\n  // first byte MUST be either 80 or FF\n  // 80 for positive, FF for 2's comp\n  var positive\n  if (buf[0] === 0x80) positive = true\n  else if (buf[0] === 0xFF) positive = false\n  else return null\n\n  // build up a base-256 tuple from the least sig to the highest\n  var zero = false\n    , tuple = []\n  for (var i = buf.length - 1; i > 0; i --) {\n    var byte = buf[i]\n    if (positive) tuple.push(byte)\n    else if (zero && byte === 0) tuple.push(0)\n    else if (zero) {\n      zero = false\n      tuple.push(0x100 - byte)\n    } else tuple.push(0xFF - byte)\n  }\n\n  for (var sum = 0, i = 0, l = tuple.length; i < l; i ++) {\n    sum += tuple[i] * Math.pow(256, i)\n  }\n\n  return positive ? sum : -1 * sum\n}\n\nfunction parseNumeric (f) {\n  if (f[0] & 0x80) return parse256(f)\n\n  var str = f.toString(\"utf8\").split(\"\\0\")[0].trim()\n    , res = parseInt(str, 8)\n\n  return isNaN(res) ? null : res\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}