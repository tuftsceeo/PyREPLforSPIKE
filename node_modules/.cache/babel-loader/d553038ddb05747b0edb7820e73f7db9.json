{"ast":null,"code":"// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\nmodule.exports = Parse.create = Parse;\n\nvar stream = require(\"stream\"),\n    Stream = stream.Stream,\n    BlockStream = require(\"block-stream\"),\n    tar = require(\"../tar.js\"),\n    TarHeader = require(\"./header.js\"),\n    Entry = require(\"./entry.js\"),\n    BufferEntry = require(\"./buffer-entry.js\"),\n    ExtendedHeader = require(\"./extended-header.js\"),\n    assert = require(\"assert\").ok,\n    inherits = require(\"inherits\"),\n    fstream = require(\"fstream\"); // reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\n\n\ninherits(Parse, fstream.Reader);\n\nfunction Parse() {\n  var me = this;\n  if (!(me instanceof Parse)) return new Parse(); // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n\n  Stream.apply(me);\n  me.writable = true;\n  me.readable = true;\n  me._stream = new BlockStream(512);\n  me.position = 0;\n  me._ended = false;\n  me._hardLinks = {};\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e);\n  });\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c);\n  });\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd();\n  });\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\");\n  });\n} // overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\n\n\nParse.prototype._streamEnd = function () {\n  var me = this;\n  if (!me._ended || me._entry) me.error(\"unexpected eof\");\n  me.emit(\"end\");\n}; // a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\n\n\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\");\n    }\n\n    return;\n  }\n\n  return this._stream.write(c);\n};\n\nParse.prototype.end = function (c) {\n  this._ended = true;\n  return this._stream.end(c);\n}; // don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\n\n\nParse.prototype._read = function () {};\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\"); // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry;\n    if (!entry._abort) entry.write(c);else {\n      entry._remaining -= c.length;\n      if (entry._remaining < 0) entry._remaining = 0;\n    }\n\n    if (entry._remaining === 0) {\n      entry.end();\n      this._entry = null;\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true;\n\n    for (var i = 0; i < 512 && zero; i++) {\n      zero = c[i] === 0;\n    } // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n\n\n    if (zero) {\n      if (this._eofStarted) this._ended = true;\n      this._eofStarted = true;\n    } else {\n      this._eofStarted = false;\n\n      this._startEntry(c);\n    }\n  }\n\n  this.position += 512;\n}; // take a header chunk, start the right kind of entry.\n\n\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c),\n      self = this,\n      entry,\n      ev,\n      EntryType,\n      onend,\n      meta = false;\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\");\n    e.header = header;\n    e.tar_file_offset = this.position;\n    e.tar_block = this.position / 512;\n    return this.emit(\"error\", e);\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry;\n      ev = \"entry\";\n      break;\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader;\n\n      onend = function () {\n        self._global = self._global || {};\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k];\n        });\n      };\n\n      ev = \"globalExtendedHeader\";\n      meta = true;\n      break;\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader;\n\n      onend = function () {\n        self._extended = entry.fields;\n      };\n\n      ev = \"extendedHeader\";\n      meta = true;\n      break;\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry;\n\n      onend = function () {\n        self._extended = self._extended || {};\n        self._extended.linkpath = entry.body;\n      };\n\n      ev = \"longLinkpath\";\n      meta = true;\n      break;\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry;\n\n      onend = function () {\n        self._extended = self._extended || {};\n        self._extended.path = entry.body;\n      };\n\n      ev = \"longPath\";\n      meta = true;\n      break;\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry;\n      ev = \"ignoredEntry\";\n      break;\n  }\n\n  var global, extended;\n\n  if (meta) {\n    global = extended = null;\n  } else {\n    var global = this._global;\n    var extended = this._extended; // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n\n    this._extended = null;\n  }\n\n  entry = new EntryType(header, extended, global);\n  entry.meta = meta; // only proxy data events of normal files.\n\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c);\n    });\n  }\n\n  if (onend) entry.on(\"end\", onend);\n  this._entry = entry;\n\n  if (entry.type === \"Link\") {\n    this._hardLinks[entry.path] = entry;\n  }\n\n  var me = this;\n  entry.on(\"pause\", function () {\n    me.pause();\n  });\n  entry.on(\"resume\", function () {\n    me.resume();\n  });\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry);\n  }\n\n  this.emit(ev, entry); // Zero-byte entry.  End immediately.\n\n  if (entry.props.size === 0) {\n    entry.end();\n    this._entry = null;\n  }\n};","map":{"version":3,"names":["module","exports","Parse","create","stream","require","Stream","BlockStream","tar","TarHeader","Entry","BufferEntry","ExtendedHeader","assert","ok","inherits","fstream","Reader","me","apply","writable","readable","_stream","position","_ended","_hardLinks","on","e","emit","c","_process","_streamEnd","prototype","_entry","error","write","i","l","length","end","_read","entry","_abort","_remaining","zero","_eofStarted","_startEntry","header","self","ev","EntryType","onend","meta","size","cksumValid","Error","tar_file_offset","tar_block","types","type","_global","Object","keys","fields","forEach","k","_extended","linkpath","body","path","global","extended","pause","resume","listeners","props"],"sources":["C:/Users/gsess/node_modules/tar/lib/parse.js"],"sourcesContent":["\n// A writable stream.\n// It emits \"entry\" events, which provide a readable stream that has\n// header info attached.\n\nmodule.exports = Parse.create = Parse\n\nvar stream = require(\"stream\")\n  , Stream = stream.Stream\n  , BlockStream = require(\"block-stream\")\n  , tar = require(\"../tar.js\")\n  , TarHeader = require(\"./header.js\")\n  , Entry = require(\"./entry.js\")\n  , BufferEntry = require(\"./buffer-entry.js\")\n  , ExtendedHeader = require(\"./extended-header.js\")\n  , assert = require(\"assert\").ok\n  , inherits = require(\"inherits\")\n  , fstream = require(\"fstream\")\n\n// reading a tar is a lot like reading a directory\n// However, we're actually not going to run the ctor,\n// since it does a stat and various other stuff.\n// This inheritance gives us the pause/resume/pipe\n// behavior that is desired.\ninherits(Parse, fstream.Reader)\n\nfunction Parse () {\n  var me = this\n  if (!(me instanceof Parse)) return new Parse()\n\n  // doesn't apply fstream.Reader ctor?\n  // no, becasue we don't want to stat/etc, we just\n  // want to get the entry/add logic from .pipe()\n  Stream.apply(me)\n\n  me.writable = true\n  me.readable = true\n  me._stream = new BlockStream(512)\n  me.position = 0\n  me._ended = false\n  me._hardLinks = {}\n\n  me._stream.on(\"error\", function (e) {\n    me.emit(\"error\", e)\n  })\n\n  me._stream.on(\"data\", function (c) {\n    me._process(c)\n  })\n\n  me._stream.on(\"end\", function () {\n    me._streamEnd()\n  })\n\n  me._stream.on(\"drain\", function () {\n    me.emit(\"drain\")\n  })\n}\n\n// overridden in Extract class, since it needs to\n// wait for its DirWriter part to finish before\n// emitting \"end\"\nParse.prototype._streamEnd = function () {\n  var me = this\n  if (!me._ended || me._entry) me.error(\"unexpected eof\")\n  me.emit(\"end\")\n}\n\n// a tar reader is actually a filter, not just a readable stream.\n// So, you should pipe a tarball stream into it, and it needs these\n// write/end methods to do that.\nParse.prototype.write = function (c) {\n  if (this._ended) {\n    // gnutar puts a LOT of nulls at the end.\n    // you can keep writing these things forever.\n    // Just ignore them.\n    for (var i = 0, l = c.length; i > l; i ++) {\n      if (c[i] !== 0) return this.error(\"write() after end()\")\n    }\n    return\n  }\n  return this._stream.write(c)\n}\n\nParse.prototype.end = function (c) {\n  this._ended = true\n  return this._stream.end(c)\n}\n\n// don't need to do anything, since we're just\n// proxying the data up from the _stream.\n// Just need to override the parent's \"Not Implemented\"\n// error-thrower.\nParse.prototype._read = function () {}\n\nParse.prototype._process = function (c) {\n  assert(c && c.length === 512, \"block size should be 512\")\n\n  // one of three cases.\n  // 1. A new header\n  // 2. A part of a file/extended header\n  // 3. One of two or more EOF null blocks\n\n  if (this._entry) {\n    var entry = this._entry\n    if(!entry._abort) entry.write(c)\n    else {\n      entry._remaining -= c.length\n      if(entry._remaining < 0) entry._remaining = 0\n    }\n    if (entry._remaining === 0) {\n      entry.end()\n      this._entry = null\n    }\n  } else {\n    // either zeroes or a header\n    var zero = true\n    for (var i = 0; i < 512 && zero; i ++) {\n      zero = c[i] === 0\n    }\n\n    // eof is *at least* 2 blocks of nulls, and then the end of the\n    // file.  you can put blocks of nulls between entries anywhere,\n    // so appending one tarball to another is technically valid.\n    // ending without the eof null blocks is not allowed, however.\n    if (zero) {\n      if (this._eofStarted)\n        this._ended = true\n      this._eofStarted = true\n    } else {\n      this._eofStarted = false\n      this._startEntry(c)\n    }\n  }\n\n  this.position += 512\n}\n\n// take a header chunk, start the right kind of entry.\nParse.prototype._startEntry = function (c) {\n  var header = new TarHeader(c)\n    , self = this\n    , entry\n    , ev\n    , EntryType\n    , onend\n    , meta = false\n\n  if (null === header.size || !header.cksumValid) {\n    var e = new Error(\"invalid tar file\")\n    e.header = header\n    e.tar_file_offset = this.position\n    e.tar_block = this.position / 512\n    return this.emit(\"error\", e)\n  }\n\n  switch (tar.types[header.type]) {\n    case \"File\":\n    case \"OldFile\":\n    case \"Link\":\n    case \"SymbolicLink\":\n    case \"CharacterDevice\":\n    case \"BlockDevice\":\n    case \"Directory\":\n    case \"FIFO\":\n    case \"ContiguousFile\":\n    case \"GNUDumpDir\":\n      // start a file.\n      // pass in any extended headers\n      // These ones consumers are typically most interested in.\n      EntryType = Entry\n      ev = \"entry\"\n      break\n\n    case \"GlobalExtendedHeader\":\n      // extended headers that apply to the rest of the tarball\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._global = self._global || {}\n        Object.keys(entry.fields).forEach(function (k) {\n          self._global[k] = entry.fields[k]\n        })\n      }\n      ev = \"globalExtendedHeader\"\n      meta = true\n      break\n\n    case \"ExtendedHeader\":\n    case \"OldExtendedHeader\":\n      // extended headers that apply to the next entry\n      EntryType = ExtendedHeader\n      onend = function () {\n        self._extended = entry.fields\n      }\n      ev = \"extendedHeader\"\n      meta = true\n      break\n\n    case \"NextFileHasLongLinkpath\":\n      // set linkpath=<contents> in extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.linkpath = entry.body\n      }\n      ev = \"longLinkpath\"\n      meta = true\n      break\n\n    case \"NextFileHasLongPath\":\n    case \"OldGnuLongPath\":\n      // set path=<contents> in file-extended header\n      EntryType = BufferEntry\n      onend = function () {\n        self._extended = self._extended || {}\n        self._extended.path = entry.body\n      }\n      ev = \"longPath\"\n      meta = true\n      break\n\n    default:\n      // all the rest we skip, but still set the _entry\n      // member, so that we can skip over their data appropriately.\n      // emit an event to say that this is an ignored entry type?\n      EntryType = Entry\n      ev = \"ignoredEntry\"\n      break\n  }\n\n  var global, extended\n  if (meta) {\n    global = extended = null\n  } else {\n    var global = this._global\n    var extended = this._extended\n\n    // extendedHeader only applies to one entry, so once we start\n    // an entry, it's over.\n    this._extended = null\n  }\n  entry = new EntryType(header, extended, global)\n  entry.meta = meta\n\n  // only proxy data events of normal files.\n  if (!meta) {\n    entry.on(\"data\", function (c) {\n      me.emit(\"data\", c)\n    })\n  }\n\n  if (onend) entry.on(\"end\", onend)\n\n  this._entry = entry\n\n  if (entry.type === \"Link\") {\n    this._hardLinks[entry.path] = entry\n  }\n\n  var me = this\n\n  entry.on(\"pause\", function () {\n    me.pause()\n  })\n\n  entry.on(\"resume\", function () {\n    me.resume()\n  })\n\n  if (this.listeners(\"*\").length) {\n    this.emit(\"*\", ev, entry)\n  }\n\n  this.emit(ev, entry)\n\n  // Zero-byte entry.  End immediately.\n  if (entry.props.size === 0) {\n    entry.end()\n    this._entry = null\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}