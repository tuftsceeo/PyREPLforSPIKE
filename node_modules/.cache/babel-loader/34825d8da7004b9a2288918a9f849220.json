{"ast":null,"code":"// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\nmodule.exports = DirWriter;\n\nvar Writer = require('./writer.js');\n\nvar inherits = require('inherits');\n\nvar mkdir = require('mkdirp');\n\nvar path = require('path');\n\nvar collect = require('./collect.js');\n\ninherits(DirWriter, Writer);\n\nfunction DirWriter(props) {\n  var self = this;\n\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true);\n  } // should already be established as a Directory type\n\n\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' + JSON.stringify(props), null, true);\n  }\n\n  Writer.call(this, props);\n}\n\nDirWriter.prototype._create = function () {\n  var self = this;\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er); // ready to start getting entries!\n\n    self.ready = true;\n    self.emit('ready');\n\n    self._process();\n  });\n}; // a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\n\n\nDirWriter.prototype.write = function () {\n  return true;\n};\n\nDirWriter.prototype.end = function () {\n  this._ended = true;\n\n  this._process();\n};\n\nDirWriter.prototype.add = function (entry) {\n  var self = this; // console.error('\\tadd', entry._path, '->', self._path)\n\n  collect(entry);\n\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry);\n\n    return false;\n  } // create a new writer, and pipe the incoming entry into it.\n\n\n  if (self._ended) {\n    return self.error('add after end');\n  }\n\n  self._buffer.push(entry);\n\n  self._process();\n\n  return this._buffer.length === 0;\n};\n\nDirWriter.prototype._process = function () {\n  var self = this; // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return;\n\n  var entry = self._buffer.shift();\n\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain');\n    if (self._ended) self._finish();\n    return;\n  }\n\n  self._processing = true; // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry); // ok, add this entry\n  //\n  // don't allow recursive copying\n\n  var p = entry;\n  var pp;\n\n  do {\n    pp = p._path || p.path;\n\n    if (pp === self.root._path || pp === self._path || pp && pp.indexOf(self._path) === 0) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false;\n      if (entry._collected) entry.pipe();\n      return self._process();\n    }\n\n    p = p.parent;\n  } while (p); // console.error(\"DW not recursive\")\n  // chop off the entry's root dir, replace with ours\n\n\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  };\n  pp = entry._path || entry.path || entry.props.path;\n\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1);\n  } // get rid of any ../../ shenanigans\n\n\n  props.path = path.join(self.path, path.join('/', pp)); // if i have a filter, the child should inherit it.\n\n  props.filter = self.filter; // all the rest of the stuff, copy over from the source.\n\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k];\n    }\n  }); // not sure at this point what kind of writer this is.\n\n  var child = self._currentChild = new Writer(props);\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child);\n    entry.resume();\n  }); // XXX Make this work in node.\n  // Long filenames should not break stuff.\n\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er);\n      child.emit('end');\n      child.emit('close');\n    } else {\n      self.emit('error', er);\n    }\n  }); // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n\n  child.on('close', onend);\n  var ended = false;\n\n  function onend() {\n    if (ended) return;\n    ended = true; // console.error(\"* DW Child end\", child.basename)\n\n    self._currentChild = null;\n    self._processing = false;\n\n    self._process();\n  }\n};","map":{"version":3,"names":["module","exports","DirWriter","Writer","require","inherits","mkdir","path","collect","props","self","error","type","Directory","JSON","stringify","call","prototype","_create","_path","dirmode","er","ready","emit","_process","write","end","_ended","add","entry","_currentEntry","_buffer","push","length","_processing","shift","_finish","p","pp","root","indexOf","_collected","pipe","parent","depth","substr","join","filter","Object","keys","forEach","k","hasOwnProperty","child","_currentChild","on","resume","_swallowErrors","warn","onend","ended"],"sources":["C:/Users/gsess/node_modules/fstream/lib/dir-writer.js"],"sourcesContent":["// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter\n\nvar Writer = require('./writer.js')\nvar inherits = require('inherits')\nvar mkdir = require('mkdirp')\nvar path = require('path')\nvar collect = require('./collect.js')\n\ninherits(DirWriter, Writer)\n\nfunction DirWriter (props) {\n  var self = this\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true)\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' +\n      JSON.stringify(props), null, true)\n  }\n\n  Writer.call(this, props)\n}\n\nDirWriter.prototype._create = function () {\n  var self = this\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er)\n    // ready to start getting entries!\n    self.ready = true\n    self.emit('ready')\n    self._process()\n  })\n}\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true\n}\n\nDirWriter.prototype.end = function () {\n  this._ended = true\n  this._process()\n}\n\nDirWriter.prototype.add = function (entry) {\n  var self = this\n\n  // console.error('\\tadd', entry._path, '->', self._path)\n  collect(entry)\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry)\n    return false\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (self._ended) {\n    return self.error('add after end')\n  }\n\n  self._buffer.push(entry)\n  self._process()\n\n  return this._buffer.length === 0\n}\n\nDirWriter.prototype._process = function () {\n  var self = this\n\n  // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return\n\n  var entry = self._buffer.shift()\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain')\n    if (self._ended) self._finish()\n    return\n  }\n\n  self._processing = true\n  // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry)\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry\n  var pp\n  do {\n    pp = p._path || p.path\n    if (pp === self.root._path || pp === self._path ||\n      (pp && pp.indexOf(self._path) === 0)) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false\n      if (entry._collected) entry.pipe()\n      return self._process()\n    }\n    p = p.parent\n  } while (p)\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  }\n\n  pp = entry._path || entry.path || entry.props.path\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1)\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(self.path, path.join('/', pp))\n\n  // if i have a filter, the child should inherit it.\n  props.filter = self.filter\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k]\n    }\n  })\n\n  // not sure at this point what kind of writer this is.\n  var child = self._currentChild = new Writer(props)\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child)\n    entry.resume()\n  })\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er)\n      child.emit('end')\n      child.emit('close')\n    } else {\n      self.emit('error', er)\n    }\n  })\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on('close', onend)\n  var ended = false\n  function onend () {\n    if (ended) return\n    ended = true\n    // console.error(\"* DW Child end\", child.basename)\n    self._currentChild = null\n    self._processing = false\n    self._process()\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}