{"ast":null,"code":"// Essentially, this is a fstream.DirReader class, but with a\n// bit of special logic to read the specified sort of ignore files,\n// and a filter that prevents it from picking up anything excluded\n// by those files.\nvar Minimatch = require(\"minimatch\").Minimatch,\n    fstream = require(\"fstream\"),\n    DirReader = fstream.DirReader,\n    inherits = require(\"inherits\"),\n    path = require(\"path\"),\n    fs = require(\"fs\");\n\nmodule.exports = IgnoreReader;\ninherits(IgnoreReader, DirReader);\n\nfunction IgnoreReader(props) {\n  if (!(this instanceof IgnoreReader)) {\n    return new IgnoreReader(props);\n  } // must be a Directory type\n\n\n  if (typeof props === \"string\") {\n    props = {\n      path: path.resolve(props)\n    };\n  }\n\n  props.type = \"Directory\";\n  props.Directory = true;\n  if (!props.ignoreFiles) props.ignoreFiles = [\".ignore\"];\n  this.ignoreFiles = props.ignoreFiles;\n  this.ignoreRules = null; // ensure that .ignore files always show up at the top of the list\n  // that way, they can be read before proceeding to handle other\n  // entries in that same folder\n\n  if (props.sort) {\n    this._sort = props.sort === \"alpha\" ? alphasort : props.sort;\n    props.sort = null;\n  }\n\n  this.on(\"entries\", function () {\n    // if there are any ignore files in the list, then\n    // pause and add them.\n    // then, filter the list based on our ignoreRules\n    var hasIg = this.entries.some(this.isIgnoreFile, this);\n    if (!hasIg) return this.filterEntries();\n    this.addIgnoreFiles();\n  }); // we filter entries before we know what they are.\n  // however, directories have to be re-tested against\n  // rules with a \"/\" appended, because \"a/b/\" will only\n  // match if \"a/b\" is a dir, and not otherwise.\n\n  this.on(\"_entryStat\", function (entry, props) {\n    var t = entry.basename;\n\n    if (!this.applyIgnores(entry.basename, entry.type === \"Directory\", entry)) {\n      entry.abort();\n    }\n  }.bind(this));\n  DirReader.call(this, props);\n}\n\nIgnoreReader.prototype.addIgnoreFiles = function () {\n  if (this._paused) {\n    this.once(\"resume\", this.addIgnoreFiles);\n    return;\n  }\n\n  if (this._ignoreFilesAdded) return;\n  this._ignoreFilesAdded = true;\n  var newIg = this.entries.filter(this.isIgnoreFile, this),\n      count = newIg.length,\n      errState = null;\n  if (!count) return;\n  this.pause();\n\n  var then = function (er) {\n    if (errState) return;\n    if (er) return this.emit(\"error\", errState = er);\n\n    if (--count === 0) {\n      this.filterEntries();\n      this.resume();\n    } else {\n      this.addIgnoreFile(newIg[newIg.length - count], then);\n    }\n  }.bind(this);\n\n  this.addIgnoreFile(newIg[0], then);\n};\n\nIgnoreReader.prototype.isIgnoreFile = function (e) {\n  return e !== \".\" && e !== \"..\" && -1 !== this.ignoreFiles.indexOf(e);\n};\n\nIgnoreReader.prototype.getChildProps = function (stat) {\n  var props = DirReader.prototype.getChildProps.call(this, stat);\n  props.ignoreFiles = this.ignoreFiles; // Directories have to be read as IgnoreReaders\n  // otherwise fstream.Reader will create a DirReader instead.\n\n  if (stat.isDirectory()) {\n    props.type = this.constructor;\n  }\n\n  return props;\n};\n\nIgnoreReader.prototype.addIgnoreFile = function (e, cb) {\n  // read the file, and then call addIgnoreRules\n  // if there's an error, then tell the cb about it.\n  var ig = path.resolve(this.path, e);\n  fs.readFile(ig, function (er, data) {\n    if (er) return cb(er);\n    this.emit(\"ignoreFile\", e, data);\n    var rules = this.readRules(data, e);\n    this.addIgnoreRules(rules, e);\n    cb();\n  }.bind(this));\n};\n\nIgnoreReader.prototype.readRules = function (buf, e) {\n  return buf.toString().split(/\\r?\\n/);\n}; // Override this to do fancier things, like read the\n// \"files\" array from a package.json file or something.\n\n\nIgnoreReader.prototype.addIgnoreRules = function (set, e) {\n  // filter out anything obvious\n  set = set.filter(function (s) {\n    s = s.trim();\n    return s && !s.match(/^#/);\n  }); // no rules to add!\n\n  if (!set.length) return; // now get a minimatch object for each one of these.\n  // Note that we need to allow dot files by default, and\n  // not switch the meaning of their exclusion\n\n  var mmopt = {\n    matchBase: true,\n    dot: true,\n    flipNegate: true\n  },\n      mm = set.map(function (s) {\n    var m = new Minimatch(s, mmopt);\n    m.ignoreFile = e;\n    return m;\n  });\n  if (!this.ignoreRules) this.ignoreRules = [];\n  this.ignoreRules.push.apply(this.ignoreRules, mm);\n};\n\nIgnoreReader.prototype.filterEntries = function () {\n  // this exclusion is at the point where we know the list of\n  // entries in the dir, but don't know what they are.  since\n  // some of them *might* be directories, we have to run the\n  // match in dir-mode as well, so that we'll pick up partials\n  // of files that will be included later.  Anything included\n  // at this point will be checked again later once we know\n  // what it is.\n  this.entries = this.entries.filter(function (entry) {\n    // at this point, we don't know if it's a dir or not.\n    return this.applyIgnores(entry) || this.applyIgnores(entry, true);\n  }, this);\n};\n\nIgnoreReader.prototype.applyIgnores = function (entry, partial, obj) {\n  var included = true; // this = /a/b/c\n  // entry = d\n  // parent /a/b sees c/d\n\n  if (this.parent && this.parent.applyIgnores) {\n    var pt = this.basename + \"/\" + entry;\n    included = this.parent.applyIgnores(pt, partial);\n  } // Negated Rules\n  // Since we're *ignoring* things here, negating means that a file\n  // is re-included, if it would have been excluded by a previous\n  // rule.  So, negated rules are only relevant if the file\n  // has been excluded.\n  //\n  // Similarly, if a file has been excluded, then there's no point\n  // trying it against rules that have already been applied\n  //\n  // We're using the \"flipnegate\" flag here, which tells minimatch\n  // to set the \"negate\" for our information, but still report\n  // whether the core pattern was a hit or a miss.\n\n\n  if (!this.ignoreRules) {\n    return included;\n  }\n\n  this.ignoreRules.forEach(function (rule) {\n    // negation means inclusion\n    if (rule.negate && included || !rule.negate && !included) {\n      // unnecessary\n      return;\n    } // first, match against /foo/bar\n\n\n    var match = rule.match(\"/\" + entry);\n\n    if (!match) {\n      // try with the leading / trimmed off the test\n      // eg: foo/bar instead of /foo/bar\n      match = rule.match(entry);\n    } // if the entry is a directory, then it will match\n    // with a trailing slash. eg: /foo/bar/ or foo/bar/\n\n\n    if (!match && partial) {\n      match = rule.match(\"/\" + entry + \"/\") || rule.match(entry + \"/\");\n    } // When including a file with a negated rule, it's\n    // relevant if a directory partially matches, since\n    // it may then match a file within it.\n    // Eg, if you ignore /a, but !/a/b/c\n\n\n    if (!match && rule.negate && partial) {\n      match = rule.match(\"/\" + entry, true) || rule.match(entry, true);\n    }\n\n    if (match) {\n      included = rule.negate;\n    }\n  }, this);\n  return included;\n};\n\nIgnoreReader.prototype.sort = function (a, b) {\n  var aig = this.ignoreFiles.indexOf(a) !== -1,\n      big = this.ignoreFiles.indexOf(b) !== -1;\n  if (aig && !big) return -1;\n  if (big && !aig) return 1;\n  return this._sort(a, b);\n};\n\nIgnoreReader.prototype._sort = function (a, b) {\n  return 0;\n};\n\nfunction alphasort(a, b) {\n  return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;\n}","map":{"version":3,"names":["Minimatch","require","fstream","DirReader","inherits","path","fs","module","exports","IgnoreReader","props","resolve","type","Directory","ignoreFiles","ignoreRules","sort","_sort","alphasort","on","hasIg","entries","some","isIgnoreFile","filterEntries","addIgnoreFiles","entry","t","basename","applyIgnores","abort","bind","call","prototype","_paused","once","_ignoreFilesAdded","newIg","filter","count","length","errState","pause","then","er","emit","resume","addIgnoreFile","e","indexOf","getChildProps","stat","isDirectory","constructor","cb","ig","readFile","data","rules","readRules","addIgnoreRules","buf","toString","split","set","s","trim","match","mmopt","matchBase","dot","flipNegate","mm","map","m","ignoreFile","push","apply","partial","obj","included","parent","pt","forEach","rule","negate","a","b","aig","big","toLowerCase"],"sources":["C:/Users/gsess/node_modules/fstream-ignore/ignore.js"],"sourcesContent":["// Essentially, this is a fstream.DirReader class, but with a\n// bit of special logic to read the specified sort of ignore files,\n// and a filter that prevents it from picking up anything excluded\n// by those files.\n\nvar Minimatch = require(\"minimatch\").Minimatch\n, fstream = require(\"fstream\")\n, DirReader = fstream.DirReader\n, inherits = require(\"inherits\")\n, path = require(\"path\")\n, fs = require(\"fs\")\n\nmodule.exports = IgnoreReader\n\ninherits(IgnoreReader, DirReader)\n\nfunction IgnoreReader (props) {\n  if (!(this instanceof IgnoreReader)) {\n    return new IgnoreReader(props)\n  }\n\n  // must be a Directory type\n  if (typeof props === \"string\") {\n    props = { path: path.resolve(props) }\n  }\n\n  props.type = \"Directory\"\n  props.Directory = true\n\n  if (!props.ignoreFiles) props.ignoreFiles = [\".ignore\"]\n  this.ignoreFiles = props.ignoreFiles\n\n  this.ignoreRules = null\n\n  // ensure that .ignore files always show up at the top of the list\n  // that way, they can be read before proceeding to handle other\n  // entries in that same folder\n  if (props.sort) {\n    this._sort = props.sort === \"alpha\" ? alphasort : props.sort\n    props.sort = null\n  }\n\n  this.on(\"entries\", function () {\n    // if there are any ignore files in the list, then\n    // pause and add them.\n    // then, filter the list based on our ignoreRules\n\n    var hasIg = this.entries.some(this.isIgnoreFile, this)\n\n    if (!hasIg) return this.filterEntries()\n\n    this.addIgnoreFiles()\n  })\n\n  // we filter entries before we know what they are.\n  // however, directories have to be re-tested against\n  // rules with a \"/\" appended, because \"a/b/\" will only\n  // match if \"a/b\" is a dir, and not otherwise.\n  this.on(\"_entryStat\", function (entry, props) {\n    var t = entry.basename\n    if (!this.applyIgnores(entry.basename,\n                           entry.type === \"Directory\",\n                           entry)) {\n      entry.abort()\n    }\n  }.bind(this))\n\n  DirReader.call(this, props)\n}\n\n\nIgnoreReader.prototype.addIgnoreFiles = function () {\n  if (this._paused) {\n    this.once(\"resume\", this.addIgnoreFiles)\n    return\n  }\n  if (this._ignoreFilesAdded) return\n  this._ignoreFilesAdded = true\n\n  var newIg = this.entries.filter(this.isIgnoreFile, this)\n  , count = newIg.length\n  , errState = null\n\n  if (!count) return\n\n  this.pause()\n\n  var then = function (er) {\n    if (errState) return\n    if (er) return this.emit(\"error\", errState = er)\n    if (-- count === 0) {\n      this.filterEntries()\n      this.resume()\n    } else {\n      this.addIgnoreFile(newIg[newIg.length - count], then)\n    }\n  }.bind(this)\n\n  this.addIgnoreFile(newIg[0], then)\n}\n\n\nIgnoreReader.prototype.isIgnoreFile = function (e) {\n  return e !== \".\" &&\n         e !== \"..\" &&\n         -1 !== this.ignoreFiles.indexOf(e)\n}\n\n\nIgnoreReader.prototype.getChildProps = function (stat) {\n  var props = DirReader.prototype.getChildProps.call(this, stat)\n  props.ignoreFiles = this.ignoreFiles\n\n  // Directories have to be read as IgnoreReaders\n  // otherwise fstream.Reader will create a DirReader instead.\n  if (stat.isDirectory()) {\n    props.type = this.constructor\n  }\n  return props\n}\n\n\nIgnoreReader.prototype.addIgnoreFile = function (e, cb) {\n  // read the file, and then call addIgnoreRules\n  // if there's an error, then tell the cb about it.\n\n  var ig = path.resolve(this.path, e)\n  fs.readFile(ig, function (er, data) {\n    if (er) return cb(er)\n\n    this.emit(\"ignoreFile\", e, data)\n    var rules = this.readRules(data, e)\n    this.addIgnoreRules(rules, e)\n    cb()\n  }.bind(this))\n}\n\n\nIgnoreReader.prototype.readRules = function (buf, e) {\n  return buf.toString().split(/\\r?\\n/)\n}\n\n\n// Override this to do fancier things, like read the\n// \"files\" array from a package.json file or something.\nIgnoreReader.prototype.addIgnoreRules = function (set, e) {\n  // filter out anything obvious\n  set = set.filter(function (s) {\n    s = s.trim()\n    return s && !s.match(/^#/)\n  })\n\n  // no rules to add!\n  if (!set.length) return\n\n  // now get a minimatch object for each one of these.\n  // Note that we need to allow dot files by default, and\n  // not switch the meaning of their exclusion\n  var mmopt = { matchBase: true, dot: true, flipNegate: true }\n  , mm = set.map(function (s) {\n    var m = new Minimatch(s, mmopt)\n    m.ignoreFile = e\n    return m\n  })\n\n  if (!this.ignoreRules) this.ignoreRules = []\n  this.ignoreRules.push.apply(this.ignoreRules, mm)\n}\n\n\nIgnoreReader.prototype.filterEntries = function () {\n  // this exclusion is at the point where we know the list of\n  // entries in the dir, but don't know what they are.  since\n  // some of them *might* be directories, we have to run the\n  // match in dir-mode as well, so that we'll pick up partials\n  // of files that will be included later.  Anything included\n  // at this point will be checked again later once we know\n  // what it is.\n  this.entries = this.entries.filter(function (entry) {\n    // at this point, we don't know if it's a dir or not.\n    return this.applyIgnores(entry) || this.applyIgnores(entry, true)\n  }, this)\n}\n\n\nIgnoreReader.prototype.applyIgnores = function (entry, partial, obj) {\n  var included = true\n\n  // this = /a/b/c\n  // entry = d\n  // parent /a/b sees c/d\n  if (this.parent && this.parent.applyIgnores) {\n    var pt = this.basename + \"/\" + entry\n    included = this.parent.applyIgnores(pt, partial)\n  }\n\n  // Negated Rules\n  // Since we're *ignoring* things here, negating means that a file\n  // is re-included, if it would have been excluded by a previous\n  // rule.  So, negated rules are only relevant if the file\n  // has been excluded.\n  //\n  // Similarly, if a file has been excluded, then there's no point\n  // trying it against rules that have already been applied\n  //\n  // We're using the \"flipnegate\" flag here, which tells minimatch\n  // to set the \"negate\" for our information, but still report\n  // whether the core pattern was a hit or a miss.\n\n  if (!this.ignoreRules) {\n    return included\n  }\n\n  this.ignoreRules.forEach(function (rule) {\n    // negation means inclusion\n    if (rule.negate && included ||\n        !rule.negate && !included) {\n      // unnecessary\n      return\n    }\n\n    // first, match against /foo/bar\n    var match = rule.match(\"/\" + entry)\n\n    if (!match) {\n      // try with the leading / trimmed off the test\n      // eg: foo/bar instead of /foo/bar\n      match = rule.match(entry)\n    }\n\n    // if the entry is a directory, then it will match\n    // with a trailing slash. eg: /foo/bar/ or foo/bar/\n    if (!match && partial) {\n      match = rule.match(\"/\" + entry + \"/\") ||\n              rule.match(entry + \"/\")\n    }\n\n    // When including a file with a negated rule, it's\n    // relevant if a directory partially matches, since\n    // it may then match a file within it.\n    // Eg, if you ignore /a, but !/a/b/c\n    if (!match && rule.negate && partial) {\n      match = rule.match(\"/\" + entry, true) ||\n              rule.match(entry, true)\n    }\n\n    if (match) {\n      included = rule.negate\n    }\n  }, this)\n\n  return included\n}\n\n\nIgnoreReader.prototype.sort = function (a, b) {\n  var aig = this.ignoreFiles.indexOf(a) !== -1\n  , big = this.ignoreFiles.indexOf(b) !== -1\n\n  if (aig && !big) return -1\n  if (big && !aig) return 1\n  return this._sort(a, b)\n}\n\nIgnoreReader.prototype._sort = function (a, b) {\n  return 0\n}\n\nfunction alphasort (a, b) {\n  return a === b ? 0\n       : a.toLowerCase() > b.toLowerCase() ? 1\n       : a.toLowerCase() < b.toLowerCase() ? -1\n       : a > b ? 1\n       : -1\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}